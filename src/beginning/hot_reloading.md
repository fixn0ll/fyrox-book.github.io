# Горячая перезагрузка кода

Fyrox поддерживает горячую перезагрузку кода (англ. Code Hot Reloading, CHR), которая позволяет перекомпилировать код игры во время её работы. Эта функция значительно сокращает время итераций и позволяет быстро прототипировать. Таким образом, Rust становится своего рода "скриптовым" языком, но со всеми гарантиями безопасности и производительности Rust. Горячая перезагрузка кода в действии выглядит так:

<iframe width="560" height="315" src="https://www.youtube.com/embed/vq6P3Npydmw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Как использовать

> ⚠️ Если у вас есть существующий проект из одной из предыдущих версий движка, лучший способ добавить поддержку CHR — это заново сгенерировать весь проект и скопировать все ассеты и игровой код в новый проект. CHR требует очень специфической структуры проекта, и даже небольшая ошибка в ней может привести к некорректному поведению.

Использовать CHR довольно просто — проект, сгенерированный менеджером проектов или `fyrox-template`, уже содержит всё необходимое для горячей перезагрузки. Есть два способа включить поддержку горячей перезагрузки — с помощью менеджера проектов и вручную с использованием консольных команд.

### Менеджер проектов

Самый простой способ включить поддержку горячей перезагрузки — просто нажать на галочку `Hot Reloading` в менеджере проектов и нажать `Edit` или `Run`:

![горячая перезагрузка в менеджере проектов](project_manager_hot_reloading.png)

Обратите внимание на маленькую иконку "огня" — она означает, что в проекте включена эта функция. Вы можете включать или отключать её в любое время.

### Консольные команды

То же самое с использованием консольных команд требует некоторой подготовки. Сначала вам нужно скомпилировать ваш игровой плагин с помощью следующей команды:

```shell
RUSTFLAGS="-C prefer-dynamic=yes" cargo build --package game_dylib --no-default-features --features="dylib-engine" --profile dev-hot-reload
```

Эта команда скомпилирует движок в виде DLL (`fyrox_dylib.dll/so`) и плагин игры в виде DLL (`game_dylib.dll/so`). Обратите внимание на обязательную переменную окружения `RUSTFLAGS="-C prefer-dynamic=yes"`. Она заставляет компилятор динамически связывать стандартную библиотеку. Это важно, потому что если она не установлена, стандартная библиотека будет дублироваться в плагине игры и движке, что приведёт к трудноуловимым ошибкам.

> ⚠️ Переменные окружения могут быть установлены разными способами в зависимости от вашей операционной системы. На Linux они просто добавляются перед командой, на Windows требуется [отдельная команда](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/set_1#examples). Другие ОС могут иметь свои способы установки переменных окружения.

Следующий шаг — скомпилировать редактор в режиме CHR. Для этого выполните следующую команду:

```shell
RUSTFLAGS="-C prefer-dynamic=yes" cargo run --package editor --no-default-features --features="dylib" --profile dev-hot-reload
```

Эта команда скомпилирует редактор в режиме CHR и запустит его. После этого вам нужно выбрать профиль сборки в редакторе как `Debug (HR)`:

![img.png](build_profile.png)

После этого вы можете запустить игру, нажав на зелёную кнопку `Play`. Вы можете переключаться между режимом CHR и обычным режимом (статической линковки) в любое время. Помните, что если вы запускаете редактор в режиме CHR, он также будет перезагружать все изменённые плагины.

## Профили сборки

CHR использует отдельные профили сборки: `dev-hot-reload` (без оптимизаций) и `release-hot-reload` (с оптимизациями). Отдельные профили сборки позволяют быстро переключаться между статически связанными плагинами и горячей перезагрузкой кода. Это может быть полезно, если вы столкнулись с проблемами при использовании CHR (см. следующий раздел для получения дополнительной информации).

## Стабильность

CHR — это очень новая и экспериментальная функция движка. Она основана на крайне небезопасной функциональности, которая может привести к повреждению памяти, трудноуловимым ошибкам и т.д. Если вы столкнулись с необычным поведением игры после горячей перезагрузки, запустите игру в обычном режиме (статической линковки). Пожалуйста, сообщайте о любых ошибках в [трекере проблем](https://github.com/FyroxEngine/Fyrox/issues) движка. CHR была протестирована на двух относительно крупных играх — [Fish Folly](https://github.com/mrDIMAS/FishFolly) и [Station Iapetus](https://github.com/mrDIMAS/StationIapetus). Вы можете скачать эти проекты и попробовать CHR самостоятельно.

## Технические детали и ограничения

CHR использует стандартный механизм операционной системы (ОС) для работы с разделяемыми библиотеками (DLL). Практически любая ОС может загружать нативный код в работающий процесс динамически из DLL. Любая динамически загруженная библиотека может быть выгружена из памяти процесса. Это даёт прекрасную возможность перезагружать игровой код во время выполнения. Это может звучать довольно просто, но на практике существует множество проблем.

### Сущности плагинов и перезагрузка

Плагины могут предоставлять движку предопределённый набор сущностей (например, скрипты и т.д.). Эти сущности сериализуются в бинарный блок памяти перед тем, как плагин будет выгружен. Когда все плагины перезагружаются, этот блок памяти используется для восстановления состояния сущностей плагинов. Таким образом, практически все сущности плагинов должны быть сериализуемыми (реализовывать трейт `Visit`).

### Трейт-объекты

Трейт-объекты очень проблематичны при горячей перезагрузке, потому что внутри они содержат таблицу виртуальных методов (vtable) с указателями на функции. Эти указатели могут быть легко инвалидированы, если плагин выгружен. Это относится даже к трейт-объектам движка, если они создаются непосредственно со стороны плагина. Единственный способ обойти эту проблему — использовать специальные методы движка для создания его трейт-объектов. Возможно добавить линт (lint) в clippy для проверки таких случаев (см. соответствующий [issue](https://github.com/rust-lang/rust-clippy/issues/12819)).

### Висячие объекты

Текущая система плагинов старается удалить все сущности плагинов из внутренностей движка перед перезагрузкой плагинов. Однако некоторые объекты могут быть упущены этой системой, что может привести к сбою или повреждению памяти. Текущий подход к предотвращению висячих объектов основан на встроенной системе рефлексии — система плагинов проходит по всем полям каждого объекта и проверяет его имя сборки. Если имя сборки совпадает с именем сборки плагина, то этот объект должен быть удалён перед выгрузкой плагина.

### Несериализуемые сущности

Не каждый объект может быть сериализован, и в этом случае текущая система плагинов вызывает специальный метод для восстановления таких несериализуемых сущностей после горячей перезагрузки. Такие сущности могут включать соединения с сервером, очереди задач и т.д.