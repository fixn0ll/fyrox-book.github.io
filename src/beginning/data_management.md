# Управление данными

Движок использует пулы для хранения большинства объектов (узлов сцены в графе, анимаций в проигрывателе анимаций, источников звука в аудиоконтексте и т.д.). Поскольку вы будете использовать их довольно часто, рекомендуется прочитать и понять эту главу.

## Мотивация

Система владения Rust и, в частности, проверка заимствований диктуют правила управления данными. В разработке игр часто возникает необходимость ссылаться на объекты из других объектов. В таких языках, как C, это обычно достигается путём хранения сырого указателя, и на этом всё заканчивается. Это работает, но крайне небезопасно — вы рискуете либо забыть уничтожить объект и вызвать утечку памяти, либо уничтожить объект, на который всё ещё есть ссылки, и затем попытаться получить доступ к освобождённой памяти. Другие языки, такие как C++, позволяют хранить _умные указатели_ на ваши данные, которые, отслеживая количество ссылок, гарантируют, что описанное выше не произойдёт, ценой незначительных накладных расходов. В Rust также есть умные указатели, похожие на эти, но не без их ограничений. Есть `Rc/Arc` — они работают как _умные указатели_, за исключением того, что они не позволяют изменять их содержимое, только читать его. Если вам нужно изменять данные, вы используете либо `RefCell` для однопоточной среды, либо `Mutex` для многопоточной среды. Именно здесь начинаются проблемы. Для типов, таких как `Rc<RefCell>` или `Arc<Mutex>`, Rust применяет свои правила заимствования во время выполнения, которые позволяют неограниченное количество читателей, но только одного писателя. Любая попытка заимствовать данные для изменения более одного раза одновременно приведёт к ошибке во время выполнения.

Ещё одна проблема с такими общими ссылками заключается в том, что очень легко случайно создать циклические ссылки, которые предотвратят уничтожение объектов. Хотя с предыдущей проблемой можно смириться, последняя проблема особенно серьёзна в случае игр: накладные расходы на проверки во время выполнения. В случае `Rc<RefCell>` это один счётчик ссылок для доступа к данным, но в случае `Arc<Mutex>` это блокировка мьютекса.

Решение этих проблем далеко от идеального; у него, безусловно, есть свои недостатки. Вместо того чтобы разбрасывать объекты по памяти и затем управлять временем жизни каждого из них через подсчёт ссылок, мы можем хранить все объекты в одном непрерывном блоке памяти и использовать индексы для доступа к каждому объекту. Такая структура называется пулом.

## Технические детали

Пул — это эффективный метод управления данными. Пул — это вектор с записями, которые могут быть либо свободными, либо занятыми. Каждая запись, независимо от её статуса, также хранит число, называемое _номером поколения_. Оно используется для понимания, изменилась ли запись с течением времени или нет. Когда запись повторно используется, её номер поколения увеличивается, что делает все ранее созданные дескрипторы, ведущие к этой записи, недействительными. Это простой и эффективный алгоритм для отслеживания времени жизни объектов.

Для доступа к данным в записях движок использует упомянутые ранее _дескрипторы_. Дескриптор — это пара из индекса записи и номера поколения. Когда вы помещаете объект в пул, это даёт вам дескриптор, ведущий к объекту, а также текущий номер поколения записи. Номер остаётся действительным до тех пор, пока вы не "освободите" объект, что снова сделает запись свободной.

## Преимущества

- Поскольку пул — это непрерывный блок памяти, он гораздо более дружелюбен к кешу процессора. Это уменьшает количество промахов кеша процессора, что делает доступ к данным очень быстрым.
- Почти каждая сущность в Fyrox живёт в своём собственном пуле, что упрощает создание структур данных, таких как графы, где узлы ссылаются на другие узлы. В этом случае узлам просто нужно хранить дескриптор для ссылки на другие узлы.
- Простое управление временем жизни. Утечка памяти невозможна, поскольку перекрёстные ссылки могут быть выполнены только через дескрипторы.
- Быстрый произвольный доступ с постоянной сложностью.
- Дескрипторы имеют тот же размер, что и указатель на 64-битной архитектуре, всего 8 байт.

## Недостатки

- Пулы могут содержать множество пробелов между используемой памятью, что может привести к менее эффективному использованию памяти.
- Дескрипторы — это своего рода слабые ссылки, но хуже. Поскольку они не владеют никакими данными и даже не указывают на свои данные, вам нужна ссылка на экземпляр пула, чтобы заимствовать данные, на которые указывает дескриптор.
- Дескрипторы вводят уровень косвенности, который может ухудшить производительность в местах с высокой нагрузкой, требующих произвольного доступа, хотя это не слишком значимо, поскольку произвольный доступ уже несколько медленный из-за возможных промахов кеша процессора.

## Использование

Вы будете использовать `Handle` _очень часто_ при работе с Fyrox. Где же основные места использования пулов и дескрипторов? Самый крупный пример — это [граф сцены](../scene/graph.md). Он хранит все узлы в пуле и выдаёт дескрипторы для каждого узла. Каждый узел сцены хранит дескриптор на свой родительский узел и набор дескрипторов на свои дочерние узлы. Граф сцены автоматически гарантирует, что такие дескрипторы остаются действительными. В [скриптах](../scripting/script.md) вы также можете хранить дескрипторы на узлы сцены и назначать их в редакторе.

[Анимация](../animation/animation.md) — ещё одно место, где хранятся дескрипторы на анимированные узлы сцены. [Машина состояний смешивания анимаций](../animation/blending.md) хранит свой собственный граф состояний, используя пул; она также принимает дескрипторы на анимации из проигрывателя анимаций в сцене.

И этот список можно продолжать долго. Именно поэтому вам нужно понимать основные концепции управления данными, чтобы эффективно и без страха использовать Fyrox.

## Заимствование

Как только объект помещён в пул, вы должны использовать его соответствующий дескриптор, чтобы получить ссылку на него. Это можно сделать с помощью `pool.borrow(handle)` или `pool.borrow_mut(handle)`, или используя трейт `Index`: `pool[handle]`. Обратите внимание, что эти методы вызывают панику, если переданный дескриптор недействителен. Если вы хотите быть в безопасности, используйте методы `try_borrow(handle)` или `try_borrow_mut(handle)`.

```rust,no_run
# extern crate fyrox;
# use fyrox::core::pool::Pool;
#
# fn main() {
let mut pool = Pool::<u32>::new();
let handle = pool.spawn(1);

let obj = pool.borrow_mut(handle);
*obj = 11;

let obj = pool.borrow(handle);
assert_eq!(*obj, 11);
# }
```

## Освобождение

Вы можете извлечь объект из пула, вызвав `pool.free(handle)`. Это вернёт вам объект и сделает все текущие дескрипторы на него недействительными.

```rust,no_run
# extern crate fyrox;
# use fyrox::core::pool::Pool;
#
# fn main() {
let mut pool = Pool::<u32>::new();
let handle = pool.spawn(1);

pool.free(handle);

let obj = pool.try_borrow(handle);
assert_eq!(obj, None);
# }
```

## Взятие и резервирование

Иногда вам может понадобиться временно извлечь объект из пула, что-то с ним сделать, а затем вернуть его обратно, не нарушая при этом все дескрипторы на объект. Для этого есть три метода:

1) `take_reserve` + `try_take_reserve` — перемещает объект из пула, но оставляет запись в занятом состоянии. Эта функция возвращает кортеж с двумя значениями `(Ticket<T>, T)`. Последнее — это ваш объект, а первое — обёртка над его индексом, которая позволяет вам вернуть объект, когда вы закончите с ним. Это называется билетом. Обратите внимание, что попытка заимствовать перемещённый объект вызовет панику!
2) `put_back` — перемещает объект обратно, используя данный билет. Билет содержит информацию о том, куда в пуле вернуть объект.
3) `forget_ticket` — делает запись в пуле свободной. Полезно в случаях, когда вы перемещаете объект из пула, а затем решаете не возвращать его. Если это так, вы **должны** вызвать этот метод, иначе соответствующая запись останется непригодной для использования.

Пример резервирования:

```rust,no_run
# extern crate fyrox;
# use fyrox::core::pool::Pool;
#
# fn main() {
let mut pool = Pool::<u32>::new();
let handle = pool.spawn(1);

let (ticket, ref mut obj) = pool.take_reserve(handle);

*obj = 123;

// Попытка получить объект, пока существует резервирование, завершится неудачей.

let attempt_obj = pool.try_borrow(handle);
assert_eq!(attempt_obj, None);

// Верните объект обратно, чтобы снова можно было его заимствовать.

pool.put_back(ticket, *obj);

let obj = pool.borrow(handle);

assert_eq!(obj, &123);
# }
```

Пример забывания:

```rust,no_run
# extern crate fyrox;
# use fyrox::core::pool::Pool;
#
# fn main() {
let mut pool = Pool::<u32>::new();
let handle = pool.spawn(1);

let (ticket, _obj) = pool.take_reserve(handle);

pool.forget_ticket(ticket);

let obj = pool.try_borrow(handle);

assert_eq!(obj, None);
# }
```

## Итераторы

Есть несколько возможных итераторов, каждый из которых служит своей цели:

1) `iter/iter_mut` — создаёт итератор по занятым записям пула, возвращая ссылки на каждый объект.
2) `pair_iter/pair_iter_mut` — создаёт итератор по занятым записям пула, возвращая кортежи из дескриптора и ссылки на каждый объект.

```rust,no_run
# extern crate fyrox;
# use fyrox::core::pool::Pool;
#
# fn main() {
let mut pool = Pool::<u32>::new();
let _handle = pool.spawn(1);

let mut iter = pool.iter_mut();

let next_obj = iter.next().unwrap();

assert_eq!(next_obj, &1);

let next_obj = iter.next();

assert_eq!(next_obj, None);
# }
```

## Прямой доступ

У вас есть возможность получить объект из пула, используя только индекс. Методы для этого — `at` и `at_mut`.

## Проверка

Чтобы проверить, действителен ли дескриптор, вы можете использовать метод `is_valid_handle`.

## Типонезависимые дескрипторы

Модуль пула также предлагает типонезависимые дескрипторы, которые могут быть полезны в некоторых ситуациях. Однако старайтесь избегать их использования, так как они могут привести к трудноуловимым ошибкам. Типобезопасность всегда хороша :3

Типонезависимый дескриптор называется `ErasedHandle` и может быть создан вручную или из строго типизированного дескриптора. Оба типа дескрипторов взаимозаменяемы; вы можете использовать трейты `From` и `Into` для преобразования одного в другой.

### Получение дескриптора объекта по его ссылке

Если вам нужно получить дескриптор объекта, имея только ссылку на него, вы можете использовать метод `handle_of`.

### Итерация и фильтрация объектов

Метод `retain` позволяет вам фильтровать содержимое пула с помощью замыкания, предоставленного вами.