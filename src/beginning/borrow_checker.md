# Проверка заимствований (Borrow Checker)

Rust имеет [знаменитый механизм проверки заимствований](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html), который стал своего рода страшилкой для новичков. Его часто воспринимают как врага, который мешает писать что-то полезное, как вы могли привыкнуть в других языках. На самом деле, это очень полезная часть Rust, которая доказывает корректность вашей программы и не позволяет вам делать неприятные вещи, такие как повреждение памяти, гонки данных и т.д. В этой главе объясняется, как Fyrox решает наиболее распространённые проблемы с заимствованиями и делает разработку игр такой же простой, как и в любом другом игровом движке.

## Множественное заимствование

При написании логики скриптов часто возникает необходимость в множественном заимствовании некоторых данных, обычно это другие узлы сцены. В нормальных обстоятельствах вы можете заимствовать каждый узел по одному, но в других случаях вы не можете выполнить действие без одновременного заимствования двух или более узлов. В этом случае вы можете использовать множественное заимствование:

```rust
{{#include ../code/snippets/src/borrowck/mod.rs:synthetic_example}}
```

Как видите, вы можете заимствовать несколько узлов одновременно без ошибок компиляции. Правила заимствования в этом случае применяются во время выполнения. Они такие же, как стандартные правила заимствования в Rust:

1) Вы можете иметь бесконечное количество неизменяемых ссылок на один и тот же объект.
2) Вы можете иметь только одну изменяемую ссылку на один и тот же объект.

Контекст множественного заимствования предоставляет подробные сообщения об ошибках для случаев, когда заимствование не удалось. Например, он сообщит вам, если вы пытаетесь заимствовать объект для изменения, который уже был заимствован как неизменяемый (и наоборот). Он также проверяет валидность дескрипторов и сообщит, что с ними не так. Это может быть либо неверный индекс, либо номер поколения. Последнее означает, что объект по этому дескриптору был изменён, и дескриптор стал недействительным.

Предыдущий пример выглядит несколько синтетическим и не показывает реальный код, который может привести к проблемам с заимствованием. Давайте это исправим. Представьте, что вы делаете шутер, и у вас есть боты, которые могут следовать за целями и атаковать их. Тогда код может выглядеть так:

```rust
{{#include ../code/snippets/src/borrowck/mod.rs:bot_example}}
```

Как вы можете видеть, для того чтобы этот код скомпилировался, нам нужно заимствовать как минимум два узла одновременно: узел с скриптом `Bot` и узел `target`. Это потому, что мы вычисляем расстояние между двумя узлами, чтобы переключать анимации соответствующим образом (атаковать, если цель достаточно близко).

Как и любой другой подход, этот не идеален и имеет свои плюсы и минусы. Плюсы довольно просты:

- Нет ошибок компиляции — иногда Rust слишком строг к правилам заимствования, и корректный код не проходит его проверки.
- Лучшая эргономика — нет необходимости жонглировать временными переменными здесь и там для выполнения действия.

Минусы:

- Множественное заимствование немного медленнее (~1-4% в зависимости от вашего случая использования) — это происходит потому, что контекст множественного заимствования проверяет правила заимствования во время выполнения.

## Передача сообщений

Иногда код становится настолько запутанным, что его становится трудно поддерживать и понимать, что он делает. Это происходит, когда связность кода достигает определённого уровня, что требует очень широкого контекста для выполнения кода. Например, если у ботов в вашей игре есть оружие, то очень заманчиво просто заимствовать оружие и вызвать что-то вроде `weapon.shoot(..)`. Когда ваше оружие простое, это может работать нормально, однако, когда ваша игра становится больше, а оружие получает новые функции, простого `weapon.shoot(..)` может быть недостаточно. Это может быть потому, что метод `shoot` получает всё больше аргументов или по какой-то другой причине. Это довольно распространённый случай, и в целом, когда ваш код становится тесно связанным, его становится трудно поддерживать, и что более важно — это может легко привести к ошибкам компиляции, которые возникают из-за проверки заимствований. Чтобы проиллюстрировать это, давайте посмотрим на этот код:

```rust
{{#include ../code/snippets/src/borrowck/without_message_passing.rs:without_message_passing}}
```

Это, вероятно, одна из типичных реализаций стрельбы в играх — вы выпускаете луч из оружия, и если он попадает в бота, вы наносите ему некоторый урон. В этом случае боты также могут стрелять, и здесь проверка заимствований снова становится на нашем пути. Если вы попытаетесь раскомментировать строку `// weapon.shoot(ctx.handle, &mut ctx.scene.graph);`, вы получите ошибку компиляции, которая говорит вам, что `ctx.scene.graph` уже заимствован. Кажется, что мы застряли, и нам нужно как-то исправить эту проблему. Мы не можем использовать множественное заимствование в этом случае, потому что оно всё ещё применяет правила заимствования, и вместо ошибки компиляции вы получите ошибку во время выполнения.

Чтобы решить эту проблему, вы можете использовать хорошо известный механизм передачи сообщений. Основная идея заключается в том, чтобы не вызывать методы сразу, а собирать все необходимые данные для вызова и отправлять их объекту, чтобы он мог выполнить вызов позже. Вот как это будет выглядеть:

```rust
{{#include ../code/snippets/src/borrowck/message_passing.rs:message_passing}}
```

Теперь оружие подписывается на `ShootMessage` и слушает его в методе `on_message`, и оттуда оно может выполнить фактическую стрельбу без каких-либо проблем с заимствованием. Бот теперь просто отправляет `ShootMessage` вместо того, чтобы заимствовать оружие и пытаться вызвать `shoot` напрямую. Сообщения не добавляют задержку в один кадр, как вы могли подумать, они обрабатываются в том же кадре, поэтому нет десинхронизации на один или более кадров.

Этот подход с сообщениями имеет свои плюсы и минусы. Плюсы довольно значительны:

- Разделение — связность теперь очень слабая и в основном осуществляется на стороне сообщений.
- Легкость рефакторинга — поскольку связность слабая, вы можете рефакторить внутренности с низкой вероятностью сломать существующий код, что могло бы произойти из-за запутанного и сложного кода.
- Нет проблем с заимствованием — вызовы методов выполняются в разных местах, и нет конфликтов времени жизни.
- Легкость написания модульных и интеграционных тестов — это вытекает из слабой связности.

Минусы следующие:

- Передача сообщений немного медленнее, чем прямые вызовы методов (~1-7% в зависимости от вашего случая использования) — вы должны поддерживать гранулярность сообщений на разумном уровне. Не используйте передачу сообщений для небольших изменений, это, скорее всего, сделает вашу игру медленнее.