# Скрипты

Скрипт — это контейнер для игровых данных и логики, который может быть назначен узлу сцены. Fyrox использует Rust для скриптов, поэтому скрипты работают так же быстро, как и нативный код. Каждый узел сцены может иметь любое количество назначенных скриптов.

## Когда использовать скрипты, а когда нет

Скрипты предназначены для добавления данных и некоторой логики к узлам сцены. Это означает, что вы не должны использовать скрипты для хранения какого-либо глобального состояния вашей игры (используйте для этого ваш игровой плагин). Например, используйте скрипты для ваших игровых предметов, ботов, игрока, уровня и т.д. С другой стороны, **не** используйте скрипты для таблиц лидеров, игровых меню, информации о прогрессе и т.д.

Кроме того, скрипты не могут быть назначены виджетам пользовательского интерфейса из-за намеренного разделения игры и пользовательского интерфейса. Все компоненты пользовательского интерфейса должны создаваться и обрабатываться в игровом плагине вашей игры.

## Структура скрипта

Типичная структура скрипта выглядит следующим образом:

```rust,no_run
{{#include ../code/snippets/src/scripting/example.rs:example_script}}
```

Каждый скрипт должен реализовывать следующие трейты:

- `Visit` — реализует функциональность сериализации/десериализации, используется редактором для сохранения вашего объекта в файл сцены.
- `Reflect` — реализует рефлексию во время компиляции, что позволяет перебирать поля скрипта, устанавливать их значения, находить поля по их путям и т.д.
- `Debug` — предоставляет функциональность отладки, в основном для редактора, чтобы он мог преобразовать структуру и её поля в строку.
- `Clone` — делает вашу структуру клонируемой, так как мы можем клонировать объекты, мы также хотим, чтобы экземпляр скрипта мог быть клонирован.
- Реализация `Default` очень важна — система скриптов использует её для создания ваших скриптов в состоянии по умолчанию. Это необходимо для установки некоторых данных и т.д. Если это особый случай, вы всегда можете реализовать свою собственную реализацию `Default`, если это необходимо для вашего скрипта.
- `TypeUuidProvider` используется для присвоения уникального идентификатора вашему типу. Каждый скрипт **должен** иметь уникальный ID, иначе движок не сможет сохранять и загружать ваши скрипты. Чтобы сгенерировать новый UUID, используйте [Online UUID Generator](https://www.uuidgenerator.net/) или любой другой инструмент, который может генерировать UUID.
- `ComponentProvider` — предоставляет доступ к внутренним полям скрипта, помеченным атрибутом `#[component(include)]`.

Атрибут `#[visit(optional)]` используется для подавления ошибок сериализации, когда некоторые поля отсутствуют или изменены.

## Генератор шаблонов скриптов

Вы можете использовать инструмент `fyrox-template` для генерации всего необходимого шаблонного кода для нового скрипта, что делает добавление новых скриптов гораздо менее утомительным. Чтобы сгенерировать новый скрипт, используйте команду `script`:

```shell
fyrox-template script --name MyScript
```

Он создаст новый файл в директории `game/src` с именем `my_script.rs` и заполнит его необходимым кодом. Не забудьте добавить модуль с новым скриптом в `lib.rs` следующим образом:

```rust,no_run,compile_fail
// Используйте имя вашего скрипта вместо `my_script` здесь.
pub mod my_script;
```

Комментарии в каждом сгенерированном методе помогут вам понять, какой код должен быть размещён где и какова цель каждого метода.

> ⚠️ Помните, что каждый новый скрипт должен быть зарегистрирован в `PluginConstructor::register`, иначе вы не сможете назначить скрипт в редакторе узлу. Подробнее см. в следующем разделе.

## Регистрация скриптов

Каждый скрипт должен быть зарегистрирован перед использованием, иначе движок не "увидит" ваш скрипт и не позволит вам назначить его объекту. Трейт `PluginConstructor` имеет метод `register` именно для регистрации скриптов. Чтобы зарегистрировать скрипт, вам нужно добавить его в список конструкторов скриптов следующим образом:

```rust,no_run
{{#include ../code/snippets/src/scripting/example.rs:register}}
```

Каждый тип скрипта (`MyScript` в приведённом выше фрагменте кода, вам нужно изменить его на ваш тип скрипта) должен быть зарегистрирован с использованием метода [ScriptConstructorsContainer::add](https://docs.rs/fyrox/latest/fyrox/script/constructor/struct.ScriptConstructorContainer.html#method.add), который принимает тип скрипта в качестве обобщённого аргумента и его имя, которое будет отображаться в редакторе. Имя может быть произвольным, оно используется только в редакторе. Вы также можете изменить его в любое время, это не сломает существующие сцены.

## Назначение скриптов

Чтобы назначить скрипт и увидеть его в действии, запустите редактор, выберите объект и найдите свойство `Scripts` в Инспекторе. Нажмите на маленькую кнопку `+` и выберите ваш скрипт из выпадающего списка на только что добавленной записи. Чтобы увидеть скрипт в действии, нажмите кнопку "Play/Stop". Редактор запустит вашу игру в отдельном процессе с активной сценой в редакторе.

Скрипт может быть назначен узлу сцены из кода:

```rust, no_run
{{#include ../code/snippets/src/scripting/example.rs:add_my_script}}
```

Инициализация, а также обновление только что назначенного скрипта произойдут на следующем тике обновления движка.

## Контекст скрипта

Контекст скрипта предоставляет доступ к окружению, которое может использоваться для изменения состояния движка и игры из скриптов. Типичное содержимое контекста выглядит следующим образом:

```rust,no_run
{{#include ../code/snippets/src/scripting/context.rs:context}}
```

- `dt` — количество времени, прошедшее с последнего кадра. Значение переменной зависит от реализации, обычно это что-то вроде 1/60 (0.016) секунды.
- `elapsed_time` — количество времени, прошедшее с начала вашей игры (в секундах).
- `plugins` — изменяемая ссылка на все зарегистрированные плагины, она позволяет вам получить доступ к некоторым "глобальным" игровым данным, которые не принадлежат ни одному объекту. Например, плагин может хранить карту клавиш, используемую для управления игроком, вы можете получить доступ к ней с помощью поля `plugins` и найти нужный плагин. В случае одного плагина вам просто нужно привести ссылку к определённому типу с помощью вызова `context.plugins[0].cast::<MyPlugin>().unwrap()`.
- `handle` — дескриптор узла, к которому назначен скрипт (родительский узел). Вы можете заимствовать узел с помощью вызова `context.scene.graph[handle]`. Приведение типов может использоваться для получения ссылки на определённый тип узла.
- `scene` — ссылка на родительскую сцену скрипта, она предоставляет вам полный доступ к содержимому сцены, позволяя добавлять/изменять/удалять узлы сцены.
- `scene_handle` — дескриптор сцены, к которой принадлежит экземпляр скрипта.
- `resource_manager` — ссылка на менеджер ресурсов, вы можете использовать его для загрузки и инстанцирования ассетов.
- `message_sender` — отправитель сообщений. Каждое сообщение, отправленное через этот отправитель, будет затем передано в метод `ScriptTrait::on_message` каждого скрипта.
- `message_dispatcher` — диспетчер сообщений. Если вам нужно получать сообщения определённого типа, вы должны явно подписаться на этот тип.
- `task_pool` — пул задач для управления асинхронными задачами.
- `graphics_context` — текущий графический контекст движка.
- `user_interfaces` — ссылка на контейнер пользовательских интерфейсов движка. Движок гарантирует, что существует хотя бы один пользовательский интерфейс. Используйте `context.user_interfaces.first()/first_mut()`, чтобы получить ссылку на него.
- `script_index` — индекс скрипта. Никогда не сохраняйте этот индекс, он действителен только пока существует этот контекст!

## Порядок выполнения

Скрипты имеют строго определённый порядок выполнения своих методов (порядок выполнения линейный и **не** зависит от фактической структуры дерева графа, в котором находится скрипт):

- `on_init` — вызывается первым для каждого экземпляра скрипта.
- `on_start` — вызывается после того, как каждый `on_init` был вызван.
- `on_update` — вызывается ноль или более раз за один кадр рендеринга. Движок стабилизирует частоту обновления логики, поэтому, если ваша игра работает на 15 FPS, логика всё равно будет работать на 60 FPS, и `on_update` будет вызываться 4 раза за кадр. Метод также может не вызываться вообще, если FPS очень высокий. Например, если ваша игра работает на 240 FPS, то `on_update` будет вызываться один раз за 4 кадра.
- `on_message` — вызывается один раз для каждого входящего сообщения.
- `on_os_event` — вызывается один раз для каждого входящего события ОС.
- `on_deinit` — вызывается в конце цикла обновления один раз, когда скрипт (или родительский узел) собирается быть удалён.

Если у узла сцены назначено несколько скриптов, то они будут обрабатываться, как описано выше, в том же порядке, в котором они были назначены узлу сцены.

## Передача сообщений

Система скриптов Fyrox поддерживает передачу сообщений между скриптами. Передача сообщений — это механизм, который позволяет вам отправлять некоторые данные (сообщение) узлу, иерархии узлов или всему графу. Каждый скрипт может подписаться на определённый тип сообщения. Это эффективный способ разделения скриптов друг от друга. Например, вы можете захотеть обнаружить и отреагировать на какое-то событие в вашей игре. В этом случае, когда событие произошло, вы отправляете сообщение определённого типа, и каждый "подписчик" отреагирует на него. Таким образом, подписчики не будут знать ничего об отправителе(ях); они будут использовать только данные сообщения для выполнения некоторых действий.

Простой пример, где передача сообщений может быть полезной, — это когда вам нужно отреагировать на какое-то событие в вашей игре. Представьте, что у вас есть оружие в вашей игре, и оно может иметь лазерный прицел, который мигает другим цветом, когда какая-то цель была поражена. В очень наивном подходе вы можете обрабатывать все лазерные прицелы там, где вы обрабатываете все пересечения для снарядов, но это добавляет очень тесную связь между лазерным прицелом и снарядами. Это совершенно ненужная связь может быть ослаблена с помощью передачи сообщений. Вместо того чтобы обрабатывать лазерные прицелы напрямую, всё, что вам нужно сделать, — это передать сообщение `ActorDamaged { actor: Handle<Node>, attacker: Handle<Node> }`. Лазерный прицел, в свою очередь, может подписаться на такое сообщение и обрабатывать все входящие сообщения, сравнивая `attacker` с владельцем лазерного прицела, и если было попадание по `attacker`, мигать другим цветом. В коде это будет выглядеть так:

```rust,no_run
{{#include ../code/snippets/src/scripting/mod.rs:message_passing}}
```

Есть несколько ключевых моментов:

- Вы должны явно подписать экземпляр скрипта на тип сообщения, иначе сообщения этого типа не будут доставлены вашему скрипту. Это делается с помощью диспетчера сообщений: `ctx.message_dispatcher.subscribe_to::<Message>(ctx.handle);`. Это должно быть сделано в методе `on_start`, однако можно подписываться/отписываться во время выполнения.
- Вы можете реагировать на сообщения только в специальном методе `on_message` — здесь вам просто нужно проверить тип сообщения с помощью сопоставления с образцом и сделать что-то полезное.

Попробуйте использовать передачу сообщений во всех случаях, слабая связанность значительно улучшает качество и читаемость кода, однако в простых проектах её можно полностью игнорировать.

## Доступ к данным других скриптов

Каждый скрипт "живёт" на каком-то узле сцены, поэтому для доступа к данным скрипта из другого скрипта вам сначала нужно знать дескриптор узла сцены с этим скриптом. Вы можете сделать это следующим образом:

```rust,no_run
{{#include ../code/snippets/src/scripting/mod.rs:access_other_1}}
{{#include ../code/snippets/src/scripting/mod.rs:access_other_2}}
```

В этом примере у нас есть два типа скриптов: `MyScript` и `MyOtherScript`. Теперь представьте, что у нас есть два узла сцены, где первый содержит `MyScript`, а второй — `MyOtherScript`. `MyScript` знает о втором узле, храня его дескриптор в поле `second_node`. `MyScript` ждёт, пока `MyOtherScript` посчитает свой внутренний счётчик до `60.0`, а затем выводит сообщение в лог. Этот код выполняет неизменяемое заимствование и не позволяет вам изменять данные другого скрипта. Если вам нужно изменяемое заимствование, используйте метод `try_get_script_of_mut` (или `try_get_script_mut` для альтернативного кода).

Поле `second_node` скрипта `MyScript` обычно назначается в редакторе, но вы также можете найти узел в вашей сцене с помощью следующего кода:

```rust,no_run
{{#include ../code/snippets/src/scripting/mod.rs:find_node}}
```

Этот код ищет узел с именем `SomeName` и назначает его дескриптор переменной `second_node` в скрипте для последующего использования.

## Доступ к плагинам из скриптов

Иногда возникает необходимость получить доступ к данным плагина из скриптов, для этого могут быть различные причины, например, вам может понадобиться зарегистрировать бота в списке ботов. Этот список может затем использоваться для поиска целей ИИ без поиска во всём графе сцены на каждом кадре.

Доступ к плагинам из скриптов очень прост, всё, что вам нужно сделать, — это вызвать метод `get/get_mut` из `ctx.plugins`:

```rust,no_run
{{#include ../code/snippets/src/scripting/mod.rs:access_plugin}}
```

В этом примере скрипт Bot регистрирует себя в глобальном списке ботов при старте и удаляет себя из списка при уничтожении. `update` затем используется для поиска целей в этом списке.

В многопользовательских играх плагин может хранить экземпляры сервера/клиента, и скрипты могут легко получить к ним доступ, чтобы отправлять сообщения по сети другим игрокам. В общем, вы можете использовать плагины как произвольное глобальное хранилище данных для ваших скриптов.