# Плагины

Игра, основанная на Fyrox, является плагином для движка и редактора. Плагин определяет глобальную логику приложения и предоставляет набор скриптов, которые можно использовать для назначения пользовательской логики узлам сцены.

Плагин — это "точка входа" вашей игры. Он имеет фиксированный набор методов, которые можно использовать для инициализации, обновления, обработки событий операционной системы и т.д. Каждый плагин может быть связан с движком (и редактором) двумя способами: статически или динамически с использованием горячей перезагрузки. [Горячая перезагрузка кода](../beginning/hot_reloading.md) обычно используется только для целей разработки.

Основное назначение плагинов — хранить и работать с некоторыми глобальными данными приложения, которые могут использоваться в скриптах, а также предоставлять набор скриптов движку. Плагины также имеют гораздо более широкий доступ к внутренностям движка, чем скрипты. Например, можно изменять сцены, добавлять проходы рендеринга, изменять разрешение и т.д., что невозможно из скриптов.

## Структура

Структура плагина определяется трейтом [Plugin](https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html). Типичная реализация может быть сгенерирована с помощью инструмента `fyrox-template`, и она выглядит примерно так:

```rust,no_run
{{#include ../code/snippets/src/scripting/plugin.rs:plugin_structure}}
```

Как видите, структура игры (`struct Game`) реализует несколько трейтов:

- `Reflect` — необходим для статической рефлексии, чтобы инспектировать содержимое плагина.
- `Visit` — в основном необходим для горячей перезагрузки, чтобы сохранять/загружать содержимое плагина.
- `Default` — предоставляет разумное состояние по умолчанию для игры.

Трейт `Plugin` очень специфичен — он может выполнять фактическую игровую логику в одном из своих методов:

- `register` — вызывается один раз при старте, позволяя вам зарегистрировать ваши скрипты. **Важно:** Вы должны зарегистрировать все ваши скрипты здесь, иначе движок (и редактор) ничего о них не узнают. Также здесь следует регистрировать загрузчики для ваших пользовательских ресурсов. Подробнее см. в главе [Пользовательские ресурсы](../resources/custom.md).
[Редактор и плагины](#редактор-и-плагины)
- `on_deinit` — вызывается, когда игра собирается завершить работу. Может использоваться для любой очистки, например, для логирования завершения игры.
- `update` — вызывается каждый кадр с фиксированной частотой (обычно 60 Гц, но может быть настроен в Executor) после создания плагина и его полной инициализации. Это основное место, куда следует помещать _независимую от объектов_ игровую логику (например, обработку пользовательского интерфейса, управление глобальным состоянием приложения и т.д.). Вся остальная логика должна добавляться через скрипты.
- `on_os_event` — вызывается, когда главное окно приложения получает событие от операционной системы. Это может быть любое событие, такое как клавиатура, мышь, геймпад или другие события. Обратите внимание, что, как и для метода `update`, здесь следует размещать только _независимую от объектов_ логику. Скрипты также могут перехватывать события ОС.
- `on_ui_message` — вызывается, когда есть сообщение от пользовательского интерфейса. Он должен использоваться для реакции на действия пользователя (например, нажатие кнопок и т.д.).
- `on_graphics_context_initialized` — вызывается, когда графический контекст был успешно инициализирован. Этот метод может использоваться для доступа к рендереру (например, для изменения его настроек качества). Вы также можете получить доступ к экземпляру главного окна и изменить его свойства (например, заголовок, размер, разрешение и т.д.).
- `on_graphics_context_destroyed` — вызывается, когда текущий графический контекст был уничтожен. Это может произойти на небольшом количестве платформ, таких как Android. Такие платформы обычно имеют своего рода режим приостановки, в котором вам не разрешено рендерить графику, иметь "окно" и т.д.
- `before_rendering` — вызывается, когда движок собирается отрендерить новый кадр. Этот метод полезен для выполнения закадрового рендеринга (например, [пользовательского интерфейса](../ui/rendering.md#offscreen-rendering)).
- `on_scene_begin_loading` — вызывается, когда движок начинает загружать игровую сцену. Этот метод может использоваться для отображения индикатора прогресса или какого-либо экрана загрузки.
- `on_scene_loaded` — вызывается, когда движок успешно загрузил игровую сцену. Этот метод может использоваться для добавления пользовательской логики, чтобы сделать что-то с только что загруженной сценой.

## Контекст плагина

Подавляющее большинство методов принимают `PluginContext` — он предоставляет почти полный доступ к сущностям движка, включая доступ к рендереру, контейнеру сцен, менеджеру ресурсов, пользовательскому интерфейсу, главному окну приложения. Типичное содержимое контекста выглядит следующим образом:

```rust,no_run
{{#include ../code/snippets/src/scripting/context.rs:plugin_context}}
```

- `scenes` — контейнер сцен, может использоваться для управления игровыми сценами — добавления, удаления, заимствования. Пример загрузки сцены приведён в предыдущем фрагменте кода в методе `Game::new()`.
- `resource_manager` — используется для загрузки внешних ресурсов (сцен, моделей, текстур, анимаций, звуковых буферов и т.д.) из различных источников (диск, сетевое хранилище в WebAssembly и т.д.).
- `user_interfaces` — используется для создания пользовательского интерфейса для вашей игры. Интерфейс не зависит от сцены и останется неизменным, даже если создано несколько сцен. Всегда есть хотя бы один пользовательский интерфейс, к которому можно получить доступ с помощью методов `.first()/first_mut()`. Движок поддерживает неограниченное количество экземпляров пользовательских интерфейсов.
- `graphics_context` — ссылка на графический контекст, который содержит ссылку на окно и текущий рендерер. Это может быть `GraphicsContext::Uninitialized`, если ваше приложение приостановлено (возможно только на Android).
- `dt` — время, прошедшее с последнего кадра. Фактическое значение зависит от реализации, но в текущей реализации оно равно 1/60 секунды и не изменяется, даже если частота кадров меняется (движок стабилизирует частоту обновления для логики).
- `lag` — ссылка на аккумулятор времени, который хранит оставшееся количество времени, которое должно быть использовано для обновления плагина. Вызывающий код разбивает `lag` на несколько подшагов с использованием `dt` и таким образом стабилизирует частоту обновления. Основное использование этой переменной — возможность сбросить `lag`, когда вы выполняете тяжёлые вычисления в игровом цикле (например, загрузку нового уровня), чтобы движок не пытался "догнать" всё время, потраченное на тяжёлые вычисления.
- `serialization_context` — может использоваться для регистрации скриптов и конструкторов пользовательских узлов сцены во время выполнения.
- `widget_constructors` — может использоваться для регистрации пользовательских виджетов.
- `performance_statistics` — статистика производительности за последний кадр. Чтобы получить статистику производительности рендеринга, используйте метод `Renderer::get_statistics`, который можно получить из экземпляра рендерера в текущем графическом контексте.
- `elapsed_time` — количество времени (в секундах), прошедшее с момента создания движка. Имейте в виду, что это значение **не** гарантированно соответствует реальному времени. Пользователь может изменить дельта-время, с которым движок "тикает", и это дельта-время влияет на прошедшее время.
- `script_processor` — ссылка на текущий экземпляр процессора скриптов, который может использоваться для доступа к списку сцен, поддерживающих скрипты.
- `async_scene_loader` — ссылка на текущий экземпляр асинхронного загрузчика сцен. Он может использоваться для запроса загрузки новой сцены.
- `window_target` — специальное поле, которое связывает главный цикл событий приложения (не игровой цикл) с окнами, специфичными для ОС. Оно также может использоваться для изменения потока управления приложения.
- `task_pool` — пул задач для управления асинхронными задачами.

## Управление потоком

Контекст плагина предоставляет доступ к специальной переменной `window_target`, которая может использоваться для изменения потока управления приложения. Наиболее распространённое использование — закрытие игры вызовом метода `window_target.unwrap().exit()`. Обратите внимание на `unwrap()` здесь, `window_target` не может быть доступен постоянно. В идеале вы должны сделать здесь проверенный доступ.

## Редактор и плагины

Когда вы запускаете свою игру из редактора, он запускает игру как отдельный процесс, и если в редакторе открыта сцена, он сообщает экземпляру игры загрузить её при старте. Давайте внимательно посмотрим на метод `Plugin::init`:

```rust,no_run
{{#include ../code/snippets/src/scripting/plugin.rs:plugin_init}}
```

Параметр `scene_path` — это путь к сцене, которая в данный момент открыта в редакторе. Ваша игра должна использовать его, если вам нужно загрузить текущую выбранную сцену редактора в вашей игре. Однако это не строго необходимо — вы можете захотеть всегда запускать игру с определённой сцены, даже если игра запускается из редактора. Если параметр равен `None`, то в редакторе нет загруженой сцены или игра была запущена вне редактора.