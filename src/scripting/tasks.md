# Задачи (Tasks)

Fyrox поддерживает программирование на основе задач как для скриптов, так и для плагинов. Задача — это замыкание, которое выполняет что-то в отдельном потоке, а затем возвращает результат обратно в основной поток. Это очень полезный подход, который позволяет вам выполнять тяжёлые вычисления, используя всю доступную мощность процессора, а не только одно ядро с одним основным потоком. Задачи могут использоваться практически для всего, что можно выполнить как отдельную часть работы.

## Как это работает

Основной поток создаёт задачу, которая затем отправляется в пул задач. В пуле задач есть фиксированный набор рабочих потоков, которые извлекают задачи из пула, когда они есть. Код задачи затем выполняется в одном из рабочих потоков, что может занять любое количество времени. Когда задача завершена, её результат отправляется в основной поток, а затем выполняется замыкание обратного вызова для выполнения желаемого действия по завершении задачи. Обычно это что-то относительно быстрое — например, вы можете создать задачу, которая вычисляет путь на большой навигационной сетке, и когда она будет завершена, вы сохраните этот путь в одном из экземпляров вашего скрипта, из которого была создана задача. Как вы можете видеть, есть две основные части — сама задача и замыкание. Графически это можно представить следующим образом:

![Задача](task.svg)

Зелёная линия представляет основной поток, а две фиолетовые линии — рабочие потоки. Рабочих потоков может быть любое количество, и обычно это один рабочий поток на каждое ядро процессора. Давайте рассмотрим типичный путь задачи на этом изображении (желтоватый). Сначала мы создаём задачу, и она сразу же помещается в пул задач (в том же потоке), после этого, если у нас есть свободный рабочий поток, он извлекает нашу задачу из пула и отправляет её на выполнение. Как вы можете видеть, любая задача должна реализовывать трейт `Send`, иначе вы получите _ошибку компиляции_. Когда задача завершена, рабочий поток отправляет результат (опять же, результат должен быть `Send`) в основной поток, и связанное замыкание обратного вызова выполняется, чтобы сделать что-то с результатом. Пока задача выполняется, основной поток не блокируется и может выполнять другие полезные действия.

## Примеры

Следующий пример вычисляет путь на навигационной сетке с использованием подхода на основе задач, описанного выше. Сначала он подготавливает "окружение" для задачи, копируя общую навигационную сетку (`Arc<RwLock<NavMesh>>`) в локальную переменную. Затем он создаёт новую задачу (блок `async move { .. }`), которая читает общую навигационную сетку и вычисляет длинный путь, который может занять несколько кадров для вычисления (представьте огромный остров, и нам нужно получить путь из одного угла в другой). В качестве последнего аргумента метода `spawn_script_task` мы передаём замыкание, которое будет выполнено в основном потоке, когда задача завершится. Оно просто сохраняет вычисленный путь в поле скрипта, который затем используется для визуализации.

```rust,no_run
{{#include ../code/snippets/src/scripting/tasks.rs:script_task}}
```

Плагины также могут создавать задачи, которые работают на уровне приложения, в отличие от задач скриптов, которые работают с отдельными экземплярами скриптов. Задача плагина немного проще в использовании:

```rust,no_run
{{#include ../code/snippets/src/scripting/tasks.rs:plugin_task}}
```

## Производительность

Вам следует избегать подхода на основе задач для небольших (с точки зрения времени) задач, потому что каждая задача имеет дополнительные затраты, которые могут быть больше, чем фактическая задача, выполняемая на месте. Это связано с тем, что вам нужно отправить вашу задачу в отдельный поток с использованием канала, затем замыкание обратного вызова сохраняется как объект-трейт, что требует выделения памяти. Поскольку задачи используют технику стирания типов, они выполняют динамическое приведение типов, что также не бесплатно. Также могут быть другие "медленные" места, определённые реализацией.

Общий совет: сначала запустите профилировщик, чтобы найти узкие места в вашей игре, затем попытайтесь их оптимизировать. Если вы достигли предела оптимизации, используйте задачи. Не используйте задачи, пока они вам действительно не понадобятся, сначала попробуйте оптимизировать вашу игру! Если вы работаете над простой 2D-игрой, вам никогда не понадобится использовать задачи. Вам может понадобиться использовать задачи, если у вас, например, процедурно генерируемый мир, который должен создаваться на лету. Например, если вы делаете dungeon crawler с бесконечным миром. Задачи также очень полезны для больших игр с большим количеством контента и активностей. Вы можете вынести ИИ, манипуляции с миром (например, если у вас разрушаемый мир) и т.д. на отдельные потоки. Другими словами — не используйте кувалду для забивания гвоздей, если у вас нет _огромного_ гвоздя.